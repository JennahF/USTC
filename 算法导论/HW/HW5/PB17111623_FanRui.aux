\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}}{1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}考虑一个大小为 m = 1000 的散列表和一个对应的散列函数 $h(k) = \delimiter "4262304 m(kA\ mod\ 1)\delimiter "5263305 $，其中$A = (\sqrt  {5} - 1)/2$，试计算关键字61,62,63,64和65被映射到的位置}{1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}考虑用开放寻址法将关键字 10,22,31,4,15,28,17,88,59 插入到一长度为 $m = 11$ 的散列表中，辅助散列函数为$h'(k) = k$。试说明分别用线性探查、二次探查$(c1 = 1, c2 = 3)$和双重散列$(h1(k) = k,h2(k) = 1+(k\ mod\ (m - 1)))$将这些关键字插入散列表的过程。}{1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.1}线性探查}{1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.2}二次探查}{2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.3}双重散列}{2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}因为在基于比较的排序模型中，完成$n$个元素的排序，其最坏情况下需要 $\Omega (n\qopname  \relax o{lg}n)$ 时间。试证明：任何基于比较的算法从$n$个元素的任意序列中构造一棵二叉搜索树，其最坏情况下需要 $\Omega (n\qopname  \relax o{lg}n)$ 的时间}{2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.3.1}将关键字 41,38,31,12,19,8 连续地插入一棵初始为空的红黑树之后，试画出该结果树}{3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.3.2}对于1中得到的红黑树，依次删除 8,12,19，试画出每次删除操作后的红黑树}{3}\protected@file@percent }
